<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR AR Carpet Placement</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Button to start AR session -->
    <button id="startAR">Start AR</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, carpet;
        let xrSession, hitTestSource = null;

        // Initialize Three.js scene
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Create a WebGLRenderer with XR compatibility
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Make WebGL context XR-compatible
            const glContext = renderer.getContext();
            glContext.getExtension('WEBGL_multiview'); // Optional: ensure multiview is available
            glContext.getExtension('OES_texture_float'); // Optional: enable support for floating point textures
            glContext.getExtension('OES_standard_derivatives'); // Optional: support for shaders

            // Set up basic light
            const light = new THREE.AmbientLight(0x404040, 5);
            scene.add(light);

            // Load the carpet model using GLTFLoader
            const loader = new THREE.GLTFLoader();
            loader.load(
                './Assets/carpet.glb',
                function(gltf) {
                    carpet = gltf.scene;
                    carpet.scale.set(1, 1, 1); // Adjust the scale if necessary
                    carpet.rotation.x = -Math.PI / 2; // Lay the carpet flat on the ground
                    scene.add(carpet);
                    console.log('Carpet loaded');
                },
                undefined,
                function(error) {
                    console.error('Error loading carpet model:', error);
                }
            );
        }

        // Start the XR session
        async function startXR() {
            if (navigator.xr) {
                try {
                    const session = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['hit-test']
                    });
                    console.log("XR session started");
                    xrSession = session;
                    xrSession.addEventListener('end', onSessionEnded);

                    // Create a WebGL layer that is XR compatible
                    const glLayer = new XRWebGLLayer(xrSession, renderer.getContext(), {
                        antialias: true,
                        alpha: true,
                        depth: true,
                        stencil: true
                    });

                    // Update session state with the XR-compatible WebGL context
                    xrSession.updateRenderState({ baseLayer: glLayer });

                    const referenceSpace = await xrSession.requestReferenceSpace('local');
                    xrSession.requestHitTestSource({ space: referenceSpace });

                    xrSession.requestAnimationFrame(onXRFrame);
                } catch (err) {
                    console.error("WebXR session failed:", err);
                }
            }
        }

        // Handle the XR frame rendering
        function onXRFrame(t, frame) {
            const session = frame.session;
            const referenceSpace = session.requestReferenceSpace('local');
            const hitTestSource = session.requestHitTestSource({ space: referenceSpace });

            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const pose = hit.getPose(referenceSpace);
                    carpet.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                }
            }

            renderer.render(scene, camera);
            xrSession.requestAnimationFrame(onXRFrame);
        }

        function onSessionEnded() {
            console.log('XR session ended');
        }

        // Resize listener
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        document.getElementById('startAR').addEventListener('click', () => {
            init();
            startXR();
        });
    </script>
</body>
</html>
