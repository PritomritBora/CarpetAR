<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR AR Carpet Placement</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Button to start AR session -->
    <button id="startAR">Start AR</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, carpet;
        let xrSession, hitTestSource = null;
        let referenceSpace;

        // Initialize Three.js scene
        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

            // Ensure WebGL context is XR-compatible
            const gl = renderer.getContext();
            if (gl && gl.makeXRCompatible) {
                await gl.makeXRCompatible();
            }

            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Set up a basic light
            const light = new THREE.AmbientLight(0x404040, 5); // Ambient light
            scene.add(light);

            // Load the carpet model using GLTFLoader
            const loader = new THREE.GLTFLoader();
            loader.load(
                './Assets/carpet.glb',  // Path to your GLB model
                function(gltf) {
                    carpet = gltf.scene;
                    carpet.scale.set(1, 1, 1); // Adjust the scale if necessary
                    carpet.rotation.x = -Math.PI / 2; // Lay the carpet flat on the ground
                    scene.add(carpet);
                    console.log('Carpet loaded');
                },
                undefined,
                function(error) {
                    console.error('Error loading carpet model:', error);
                }
            );

            // Set the camera's aspect ratio and update the projection matrix
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        // Start the XR session
        async function startXR() {
            if (navigator.xr) {
                try {
                    // Request an immersive AR session
                    const session = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['hit-test', 'viewer']
                    });
                    console.log("XR session started");
                    xrSession = session;
                    xrSession.addEventListener('end', onSessionEnded);

                    // Create a WebGL layer that is XR compatible
                    const glLayer = new XRWebGLLayer(xrSession, renderer.getContext(), {
                        antialias: true,
                        alpha: true,
                        depth: true,
                        stencil: true
                    });

                    // Update session state with the XR-compatible WebGL context
                    xrSession.updateRenderState({ baseLayer: glLayer });

                    // Create and request a reference space
                    referenceSpace = await xrSession.requestReferenceSpace('viewer');
                    hitTestSource = await xrSession.requestHitTestSource({ space: referenceSpace });
                    console.log("Hit Test Source: ", hitTestSource);

                    xrSession.requestAnimationFrame(onXRFrame);
                } catch (err) {
                    console.error("WebXR session failed:", err);
                }
            }
        }

        // Handle the XR frame rendering
        function onXRFrame(t, frame) {
            const session = frame.session;

            if (!referenceSpace) {
                console.error("Reference space is not available");
                return;
            }

            const viewerPose = frame.getViewerPose(referenceSpace);
            console.log("getting viewer pose");

            if (viewerPose) {
                const cameraPose = viewerPose.pose;
                if (cameraPose) {
                    camera.position.set(cameraPose.position.x, cameraPose.position.y, cameraPose.position.z);
                    camera.rotation.set(cameraPose.orientation.x, cameraPose.orientation.y, cameraPose.orientation.z, cameraPose.orientation.w);
                    }
            } else {
                console.log("No viewer pose available for this frame.");
            }

            // Continue with hit testing and carpet placement
            if (hitTestSource) {
                console.log(viewerPose)
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                console.log("Hit Test Results Length:", hitTestResults.length); // Debug log for hit test results length

                if (hitTestResults.length > 0) {
                    console.log("hitTestResults available");

                    const hit = hitTestResults[0];
                    const pose = hit.getPose(referenceSpace);
                    console.log(pose);

                    if (pose && pose.transform) {
                        const transform = pose.transform;
                        carpet.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);

                        // if (transform.orientation) {
                        //     console.log(transform.orientation)
                        //      carpet.rotation.setFromRotationMatrix(transform.orientation);
                        // } else if (transform.rotation) {
                        //         carpet.rotation.set(transform.rotation.x, transform.rotation.y, transform.rotation.z, transform.rotation.w);
                        // } else {
                        //     console.error("No valid rotation or orientation data found:", transform);
                        // }
                    } else {
                         console.error("Pose or pose transform is null or invalid:", pose);
                        }

                }
            } else {
                console.log("No hit test results found.");
            }

            renderer.render(scene, camera);
            xrSession.requestAnimationFrame(onXRFrame);
        }

        // On XR session end
        function onSessionEnded() {
            console.log('XR session ended');
        }

        // Resize listener
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
        });

        // Event listener to start AR session when button is clicked
        document.getElementById('startAR').addEventListener('click', () => {
            init();  // Initialize the scene
            startXR();  // Start the AR session
        });
    </script>
</body>
</html>
